{"version":3,"sources":["../../src/text-style/index.ts","../../src/background-color/background-color.ts","../../src/background-color/index.ts"],"sourcesContent":["import { Mark, mergeAttributes } from '@tiptap/core'\n\nimport type { TextStyleAttributes } from '../index.js'\n\nexport interface TextStyleOptions {\n  /**\n   * HTML attributes to add to the span element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n  /**\n   * When enabled, merges the styles of nested spans into the child span during HTML parsing.\n   * This prioritizes the style of the child span.\n   * Used when parsing content created in other editors.\n   * (Fix for ProseMirror's default behavior.)\n   * @default true\n   */\n  mergeNestedSpanStyles: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    textStyle: {\n      /**\n       * Remove spans without inline style attributes.\n       * @example editor.commands.removeEmptyTextStyle()\n       */\n      removeEmptyTextStyle: () => ReturnType\n      /**\n       * Toggle a text style\n       * @param attributes The text style attributes\n       * @example editor.commands.toggleTextStyle({ fontWeight: 'bold' })\n       */\n      toggleTextStyle: (attributes?: TextStyleAttributes) => ReturnType\n    }\n  }\n}\n\nconst MAX_FIND_CHILD_SPAN_DEPTH = 20\n\n/**\n * Returns all next child spans, either direct children or nested deeper\n * but won't traverse deeper into child spans found, will only go MAX_FIND_CHILD_SPAN_DEPTH levels deep (default: 20)\n */\nconst findChildSpans = (element: HTMLElement, depth = 0): HTMLElement[] => {\n  const childSpans: HTMLElement[] = []\n\n  if (!element.children.length || depth > MAX_FIND_CHILD_SPAN_DEPTH) {\n    return childSpans\n  }\n\n  Array.from(element.children).forEach(child => {\n    if (child.tagName === 'SPAN') {\n      childSpans.push(child as HTMLElement)\n    } else if (child.children.length) {\n      childSpans.push(...findChildSpans(child as HTMLElement, depth + 1))\n    }\n  })\n\n  return childSpans\n}\n\nconst mergeNestedSpanStyles = (element: HTMLElement) => {\n  if (!element.children.length) {\n    return\n  }\n\n  const childSpans = findChildSpans(element)\n\n  if (!childSpans) {\n    return\n  }\n\n  childSpans.forEach(childSpan => {\n    const childStyle = childSpan.getAttribute('style')\n    const closestParentSpanStyleOfChild = childSpan.parentElement?.closest('span')?.getAttribute('style')\n\n    childSpan.setAttribute('style', `${closestParentSpanStyleOfChild};${childStyle}`)\n  })\n}\n\n/**\n * This extension allows you to create text styles. It is required by default\n * for the `text-color` and `font-family` extensions.\n * @see https://www.tiptap.dev/api/marks/text-style\n */\nexport const TextStyle = Mark.create<TextStyleOptions>({\n  name: 'textStyle',\n\n  priority: 101,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      mergeNestedSpanStyles: true,\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'span',\n        consuming: false,\n        getAttrs: element => {\n          const hasStyles = (element as HTMLElement).hasAttribute('style')\n\n          if (!hasStyles) {\n            return false\n          }\n\n          if (this.options.mergeNestedSpanStyles) {\n            mergeNestedSpanStyles(element)\n          }\n\n          return {}\n        },\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleTextStyle:\n        attributes =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name, attributes)\n        },\n      removeEmptyTextStyle:\n        () =>\n        ({ tr }) => {\n          const { selection } = tr\n\n          // Gather all of the nodes within the selection range.\n          // We would need to go through each node individually\n          // to check if it has any inline style attributes.\n          // Otherwise, calling commands.unsetMark(this.name)\n          // removes everything from all the nodes\n          // within the selection range.\n          tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n            // Check if it's a paragraph element, if so, skip this node as we apply\n            // the text style to inline text nodes only (span).\n            if (node.isTextblock) {\n              return true\n            }\n\n            // Check if the node has no inline style attributes.\n            // Filter out non-`textStyle` marks.\n            if (\n              !node.marks\n                .filter(mark => mark.type === this.type)\n                .some(mark => Object.values(mark.attrs).some(value => !!value))\n            ) {\n              // Proceed with the removal of the `textStyle` mark for this node only\n              tr.removeMark(pos, pos + node.nodeSize, this.type)\n            }\n          })\n\n          return true\n        },\n    }\n  },\n})\n","import '../text-style/index.js'\n\nimport { Extension } from '@tiptap/core'\n\nexport type BackgroundColorOptions = {\n  /**\n   * The types where the color can be applied\n   * @default ['textStyle']\n   * @example ['heading', 'paragraph']\n   */\n  types: string[]\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    backgroundColor: {\n      /**\n       * Set the text color\n       * @param backgroundColor The color to set\n       * @example editor.commands.setColor('red')\n       */\n      setBackgroundColor: (backgroundColor: string) => ReturnType\n\n      /**\n       * Unset the text backgroundColor\n       * @example editor.commands.unsetBackgroundColor()\n       */\n      unsetBackgroundColor: () => ReturnType\n    }\n  }\n}\n\n// @ts-ignore because the module is not found during dts build\ndeclare module '@tiptap/extension-text-style' {\n  interface TextStyleAttributes {\n    backgroundColor?: string | null\n  }\n}\n\n/**\n * This extension allows you to color your text.\n * @see https://tiptap.dev/api/extensions/background-color\n */\nexport const BackgroundColor = Extension.create<BackgroundColorOptions>({\n  name: 'backgroundColor',\n\n  addOptions() {\n    return {\n      types: ['textStyle'],\n    }\n  },\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          backgroundColor: {\n            default: null,\n            parseHTML: element => {\n              // Prefer the raw inline `style` attribute so we preserve\n              // the original format (e.g. `#rrggbb`) instead of the\n              // computed `rgb(...)` value returned by `element.style.backgroundColor`.\n              // When nested spans are merged the style attribute may contain\n              // multiple `background-color:` declarations (parent;child). We should pick\n              // the last declaration so the child's background color takes priority.\n              const styleAttr = element.getAttribute('style')\n              if (styleAttr) {\n                const decls = styleAttr\n                  .split(';')\n                  .map(s => s.trim())\n                  .filter(Boolean)\n                for (let i = decls.length - 1; i >= 0; i -= 1) {\n                  const parts = decls[i].split(':')\n                  if (parts.length >= 2) {\n                    const prop = parts[0].trim().toLowerCase()\n                    const val = parts.slice(1).join(':').trim()\n                    if (prop === 'background-color') {\n                      return val.replace(/['\"]+/g, '')\n                    }\n                  }\n                }\n              }\n\n              return element.style.backgroundColor?.replace(/['\"]+/g, '')\n            },\n            renderHTML: attributes => {\n              if (!attributes.backgroundColor) {\n                return {}\n              }\n\n              return {\n                style: `background-color: ${attributes.backgroundColor}`,\n              }\n            },\n          },\n        },\n      },\n    ]\n  },\n\n  addCommands() {\n    return {\n      setBackgroundColor:\n        backgroundColor =>\n        ({ chain }) => {\n          return chain().setMark('textStyle', { backgroundColor }).run()\n        },\n      unsetBackgroundColor:\n        () =>\n        ({ chain }) => {\n          return chain().setMark('textStyle', { backgroundColor: null }).removeEmptyTextStyle().run()\n        },\n    }\n  },\n})\n","import { BackgroundColor } from './background-color.js'\n\nexport * from './background-color.js'\n\nexport default BackgroundColor\n"],"mappings":"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","names":[]}